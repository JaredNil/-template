// SOLID Принцип ООП Архитектуры
// S: Single Responsibility Principle (Принцип единственной ответственности).
// O: Open-Closed Principle (Принцип открытости-закрытости).
// L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).
// I: Interface Segregation Principle (Принцип разделения интерфейса).
// D: Dependency Inversion Principle (Принцип инверсии зависимостей).
// Принцип единственной ответственности
// 	Бизнес-логика декомпозирована на отдельные функциональности и каждая условная абстракция решает свою единую задачу.

// Принцип открытости-закрытости
// Программные сущности должны быть:
// открыты для расширения: означает, что поведение сущности может быть расширено путём создания новых типов сущностей при помощи полиморфизма.
// закрыты для изменения: в результате расширения поведения сущности, не должны вноситься изменения в код, который эту сущность использует.
// Условный пример – реализация всё через общий виртуальный класс с общей логикой написания функционала. И ветка расширяется увеличинием расширением классов дочерних, а не модификацией уже развитых.

// Принцип подстановки Барбары Лисков
// 	Дочерние классы могут служить заменой для своих родительских классов.
// 		То есть можно переопределить содержимое результата функций, но не тип вывода для каждой из них функций. И тем самым получается ожидаемое поведения для любого из дочернего класса компонента.

// 	Принцип разделения интерфейса
// 		Необходимо делегировать интерфейс на выполняемый им функционал.

// Принцип инверсии зависимостей
// -> Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.

// -> Объектом зависимости должна быть абстракция, а не что-то конкретное. Абстракция или интерфейс-декоратор является единым узлом через которую идёт обращение к низкому уровню ПО, следовательно, при изменении к обращению к API низкого уровня – необходимо будет переписать лишь один интерфейс-декоратор и всё.
